Option Explicit

#If VBA7 Then
Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hWndNewOwner As LongPtr) As Long
Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
Private Declare PtrSafe Function IsClipboardFormatAvailable Lib "user32" (ByVal wFormat As Long) As Long
Private Declare PtrSafe Function GetClipboardData Lib "user32" (ByVal wFormat As Long) As LongPtr
Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As Long
Private Declare PtrSafe Function lstrlenW Lib "kernel32" (ByVal lpString As LongPtr) As Long
#Else
Private Declare Function OpenClipboard Lib "user32" (ByVal hWndNewOwner As Long) As Long
Private Declare Function CloseClipboard Lib "user32" () As Long
Private Declare Function IsClipboardFormatAvailable Lib "user32" (ByVal wFormat As Long) As Long
Private Declare Function GetClipboardData Lib "user32" (ByVal wFormat As Long) As Long
Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
Private Declare Function lstrlenW Lib "kernel32" (ByVal lpString As Long) As Long
#End If

Private Const CF_UNICODETEXT As Long = 13

Public Sub PasteJsonTable()
    Dim wb As Workbook, ws As Worksheet
    Set wb = Application.ActiveWorkbook
    Set ws = wb.ActiveSheet
    Dim jsonText As String
    jsonText = GetJsonFromClipboardText()
    If Len(jsonText) = 0 Then
        If Not Application.Selection Is Nothing Then
            If Application.Selection.Cells.Count = 1 Then
                jsonText = CStr(Application.Selection.Value)
            End If
        End If
    End If
    If Len(jsonText) = 0 Then
        MsgBox "No JSON found.", vbExclamation
        Exit Sub
    End If
    Dim root As Variant
    SafeAppOff
    On Error GoTo CleanFail
    root = Json_Parse(jsonText)
    Dim rows As Collection
    Set rows = Json_To_Rows(root)
    If rows.Count = 0 Then
        MsgBox "No rows parsed.", vbInformation
        GoTo CleanExit
    End If
    Dim headers As Collection
    Set headers = CollectHeaders(rows)
    Dim dataArr As Variant
    dataArr = RowsTo2D(rows, headers)
    Dim tgt As Range
    Set tgt = ws.ActiveCell
    Dim outRange As Range
    Set outRange = tgt.Resize(UBound(dataArr, 1), UBound(dataArr, 2))
    outRange.Value = dataArr
    outRange.Rows(1).Font.Bold = True
    outRange.EntireColumn.AutoFit
CleanExit:
    SafeAppOn
    Exit Sub
CleanFail:
    SafeAppOn
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

Private Sub SafeAppOff()
    On Error Resume Next
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual
    Application.StatusBar = "Parsing JSON..."
End Sub

Private Sub SafeAppOn()
    On Error Resume Next
    Application.ScreenUpdating = True
    Application.EnableEvents = True
    Application.Calculation = xlCalculationAutomatic
    Application.StatusBar = False
End Sub

Private Function GetJsonFromClipboardText() As String
    Dim s As String
    #If VBA7 Then
    Dim hData As LongPtr, pData As LongPtr
    #Else
    Dim hData As Long, pData As Long
    #End If
    If IsClipboardFormatAvailable(CF_UNICODETEXT) = 0 Then Exit Function
    If OpenClipboard(0) = 0 Then Exit Function
    hData = GetClipboardData(CF_UNICODETEXT)
    If hData <> 0 Then
        pData = GlobalLock(hData)
        If pData <> 0 Then
            Dim cch As Long
            cch = lstrlenW(pData)
            If cch > 0 Then
                s = String$(cch, vbNullChar)
                Mid$(s, 1, cch) = pDataToString(pData, cch)
            End If
            GlobalUnlock hData
        End If
    End If
    CloseClipboard
    GetJsonFromClipboardText = s
End Function

Private Function pDataToString(ByVal pData As LongPtr, ByVal cch As Long) As String
    Dim arr() As Byte
    ReDim arr(0 To (cch * 2) - 1)
    Dim i As Long
    For i = 0 To UBound(arr) Step 2
        arr(i) = PeekByte(pData + i)
        arr(i + 1) = PeekByte(pData + i + 1)
    Next i
    pDataToString = arrToString(arr)
End Function

Private Function PeekByte(ByVal addr As LongPtr) As Byte
    Dim b As Byte
    CopyMemoryB b, addr
    PeekByte = b
End Function

#If VBA7 Then
Private Declare PtrSafe Sub CopyMemoryB Lib "kernel32" Alias "RtlMoveMemory" (ByRef Destination As Byte, ByVal Source As LongPtr, ByVal Length As LongPtr)
#Else
Private Declare Sub CopyMemoryB Lib "kernel32" Alias "RtlMoveMemory" (ByRef Destination As Byte, ByVal Source As Long, ByVal Length As Long)
#End If

Private Function arrToString(ByRef arr() As Byte) As String
    Dim s As String
    s = StrConv(arr, vbUnicode)
    arrToString = s
End Function

Private Function Json_To_Rows(ByVal root As Variant) As Collection
    Dim rows As New Collection
    Dim t As String: t = TypeName(root)
    If t = "Collection" Then
        Dim i As Long
        For i = 1 To root.Count
            Dim row As Object
            Set row = CreateObject("Scripting.Dictionary")
            Flatten root(i), row, ""
            rows.Add row
        Next
    ElseIf IsObject(root) Then
        Dim row2 As Object
        Set row2 = CreateObject("Scripting.Dictionary")
        Flatten root, row2, ""
        rows.Add row2
    Else
        Err.Raise vbObjectError + 1000, , "Root not object/array."
    End If
    Set Json_To_Rows = rows
End Function

Private Sub Flatten(ByVal v As Variant, ByVal bag As Object, ByVal prefix As String, Optional ByVal depth As Long = 0)
    Const MAX_DEPTH As Long = 64
    If depth > MAX_DEPTH Then Err.Raise vbObjectError + 1001, , "Too deep."
    If IsObject(v) Then
        Dim tn As String: tn = TypeName(v)
        If tn = "Collection" Then
            Dim i As Long
            For i = 1 To v.Count
                Flatten v(i), bag, IIf(prefix = "", "[" & (i - 1) & "]", prefix & "[" & (i - 1) & "]"), depth + 1
            Next
        Else
            Dim k As Variant
            For Each k In v.Keys
                Flatten v(k), bag, IIf(prefix = "", CStr(k), prefix & "." & CStr(k)), depth + 1
            Next k
        End If
    Else
        bag(prefix) = v
    End If
End Sub

Private Function CollectHeaders(ByVal rows As Collection) As Collection
    Dim seen As Object: Set seen = CreateObject("Scripting.Dictionary")
    Dim out As New Collection
    Dim i As Long
    For i = 1 To rows.Count
        Dim d As Object: Set d = rows(i)
        Dim k As Variant
        For Each k In d.Keys
            If Not seen.Exists(k) Then
                seen.Add k, True
                out.Add k
            End If
        Next k
    Next i
    Set CollectHeaders = out
End Function

Private Function RowsTo2D(ByVal rows As Collection, ByVal headers As Collection) As Variant
    Dim r As Long, c As Long
    Dim nR As Long: nR = rows.Count + 1
    Dim nC As Long: nC = headers.Count
    Dim arr As Variant
    ReDim arr(1 To nR, 1 To nC)
    For c = 1 To nC
        arr(1, c) = headers(c)
    Next c
    For r = 2 To nR
        Dim d As Object: Set d = rows(r - 1)
        For c = 1 To nC
            Dim h As String: h = headers(c)
            If d.Exists(h) Then arr(r, c) = d(h) Else arr(r, c) = vbNullString
        Next c
    Next r
    RowsTo2D = arr
End Function

Private Type JP
    s As String
    i As Long
    n As Long
End Type

Private Function Json_Parse(ByVal s As String) As Variant
    Dim p As JP
    p.s = s
    p.i = 1
    p.n = Len(s)
    SkipWS p
    Dim v As Variant
    v = ParseValue(p)
    SkipWS p
    If p.i <= p.n Then Err.Raise vbObjectError + 1002, , "Trailing characters after JSON value at pos " & p.i
    Json_Parse = v
End Function

Private Function ParseValue(ByRef p As JP) As Variant
    SkipWS p
    If p.i > p.n Then Err.Raise vbObjectError + 1003, , "Unexpected end of JSON."
    Dim ch As String: ch = Mid$(p.s, p.i, 1)
    Select Case ch
        Case """": ParseValue = ParseString(p)
        Case "{": ParseValue = ParseObject(p)
        Case "[": ParseValue = ParseArray(p)
        Case "t": ExpectLiteral p, "true": ParseValue = True
        Case "f": ExpectLiteral p, "false": ParseValue = False
        Case "n": ExpectLiteral p, "null": ParseValue = Empty
        Case "-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
            ParseValue = ParseNumber(p)
        Case Else
            Err.Raise vbObjectError + 1004, , "Unexpected character '" & ch & "' at pos " & p.i
    End Select
End Function

Private Function ParseObject(ByRef p As JP) As Variant
    p.i = p.i + 1
    SkipWS p
    Dim d As Object: Set d = CreateObject("Scripting.Dictionary")
    If Peek(p) = "}" Then p.i = p.i + 1: ParseObject = d: Exit Function
    Do
        SkipWS p
        If Peek(p) <> """" Then Err.Raise vbObjectError + 1005, , "Expected string key at pos " & p.i
        Dim key As String: key = ParseString(p)
        SkipWS p
        If Peek(p) <> ":" Then Err.Raise vbObjectError + 1006, , "Expected ':' after key at pos " & p.i
        p.i = p.i + 1
        Dim val As Variant: val = ParseValue(p)
        If d.Exists(key) Then
            d(key) = val
        Else
            d.Add key, val
        End If
        SkipWS p
        Dim ch As String: ch = Peek(p)
        If ch = "}" Then p.i = p.i + 1: Exit Do
        If ch <> "," Then Err.Raise vbObjectError + 1007, , "Expected ',' or '}' at pos " & p.i
        p.i = p.i + 1
    Loop
    ParseObject = d
End Function

Private Function ParseArray(ByRef p As JP) As Variant
    p.i = p.i + 1
    SkipWS p
    Dim a As New Collection
    If Peek(p) = "]" Then p.i = p.i + 1: Set ParseArray = a: Exit Function
    Do
        Dim v As Variant: v = ParseValue(p)
        a.Add v
        SkipWS p
        Dim ch As String: ch = Peek(p)
        If ch = "]" Then p.i = p.i + 1: Exit Do
        If ch <> "," Then Err.Raise vbObjectError + 1008, , "Expected ',' or ']' at pos " & p.i
        p.i = p.i + 1
    Loop
    Set ParseArray = a
End Function

Private Function ParseString(ByRef p As JP) As String
    p.i = p.i + 1
    Dim sb As String: sb = ""
    Do While p.i <= p.n
        Dim ch As String: ch = Mid$(p.s, p.i, 1)
        If ch = """" Then p.i = p.i + 1: ParseString = sb: Exit Function
        If ch <> "\" Then
            sb = sb & ch
            p.i = p.i + 1
        Else
            p.i = p.i + 1
            If p.i > p.n Then Err.Raise vbObjectError + 1010, , "Bad escape at end of string."
            Dim e As String: e = Mid$(p.s, p.i, 1)
            Select Case e
                Case """", "\", "/": sb = sb & e: p.i = p.i + 1
                Case "b": sb = sb & vbBack: p.i = p.i + 1
                Case "f": sb = sb & vbFormFeed: p.i = p.i + 1
                Case "n": sb = sb & vbLf: p.i = p.i + 1
                Case "r": sb = sb & vbCr: p.i = p.i + 1
                Case "t": sb = sb & vbTab: p.i = p.i + 1
                Case "u"
                    Dim hex As String
                    hex = Mid$(p.s, p.i + 1, 4)
                    If Len(hex) < 4 Or Not IsHex4(hex) Then Err.Raise vbObjectError + 1011, , "Invalid \u escape at pos " & p.i
                    sb = sb & ChrW$(CLng("&H" & hex))
                    p.i = p.i + 5
                Case Else
                    Err.Raise vbObjectError + 1012, , "Invalid escape '\\" & e & "' at pos " & p.i
            End Select
        End If
    Loop
    Err.Raise vbObjectError + 1013, , "Unterminated string."
End Function

Private Function ParseNumber(ByRef p As JP) As Variant
    Dim startI As Long: startI = p.i
    Dim ch As String
    If Peek(p) = "-" Then p.i = p.i + 1
    ch = Peek(p)
    If ch = "0" Then
        p.i = p.i + 1
    ElseIf ch >= "1" And ch <= "9" Then
        Do While p.i <= p.n And Mid$(p.s, p.i, 1) >= "0" And Mid$(p.s, p.i, 1) <= "9"
            p.i = p.i + 1
        Loop
    Else
        Err.Raise vbObjectError + 1014, , "Invalid number at pos " & p.i
    End If
    If Peek(p) = "." Then
        p.i = p.i + 1
        If Not (Mid$(p.s, p.i, 1) >= "0" And Mid$(p.s, p.i, 1) <= "9") Then Err.Raise vbObjectError + 1015, , "Invalid fraction at pos " & p.i
        Do While p.i <= p.n And Mid$(p.s, p.i, 1) >= "0" And Mid$(p.s, p.i, 1) <= "9"
            p.i = p.i + 1
        Loop
    End If
    ch = Peek(p)
    If ch = "e" Or ch = "E" Then
        p.i = p.i + 1
        If Peek(p) = "+" Or Peek(p) = "-" Then p.i = p.i + 1
        If Not (Mid$(p.s, p.i, 1) >= "0" And Mid$(p.s, p.i, 1) <= "9") Then Err.Raise vbObjectError + 1016, , "Invalid exponent at pos " & p.i
        Do While p.i <= p.n And Mid$(p.s, p.i, 1) >= "0" And Mid$(p.s, p.i, 1) <= "9"
            p.i = p.i + 1
        Loop
    End If
    Dim numStr As String: numStr = Mid$(p.s, startI, p.i - startI)
    If InStr(1, numStr, ".") > 0 Or InStr(1, numStr, "e", vbTextCompare) > 0 Then
        ParseNumber = CDbl(numStr)
    Else
        If Len(numStr) > 9 Then
            On Error GoTo asString
            ParseNumber = CLng(numStr)
            Exit Function
asString:
            ParseNumber = numStr
        Else
            ParseNumber = CLng(numStr)
        End If
    End If
End Function

Private Sub ExpectLiteral(ByRef p As JP, ByVal lit As String)
    If Mid$(p.s, p.i, Len(lit)) <> lit Then
        Err.Raise vbObjectError + 1017, , "Expected '" & lit & "' at pos " & p.i
    End If
    p.i = p.i + Len(lit)
End Sub

Private Sub SkipWS(ByRef p As JP)
    Do While p.i <= p.n
        Select Case Mid$(p.s, p.i, 1)
            Case " ", vbTab, vbCr, vbLf: p.i = p.i + 1
            Case Else: Exit Do
        End Select
    Loop
End Sub

Private Function Peek(ByRef p As JP) As String
    If p.i > p.n Then Peek = "" Else Peek = Mid$(p.s, p.i, 1)
End Function

Private Function IsHex4(ByVal s As String) As Boolean
    Dim i As Long
    If Len(s) <> 4 Then Exit Function
    For i = 1 To 4
        Dim ch As String: ch = Mid$(s, i, 1)
        If InStr(1, "0123456789abcdefABCDEF", ch, vbBinaryCompare) = 0 Then Exit Function
    Next i
    IsHex4 = True
End Function
